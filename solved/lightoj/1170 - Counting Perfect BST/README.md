### Topic

    Dynamic Programming, math, binary search


### Key Idea

  The first thing to note is the number of perfect powers between 1 and 10^10, at first we can see it is not greater than 10^5. (a\*a <= 10^10 , so a <= 10^5).

  Let's to calculate it.

  ```cpp
  for(long long i = 2; i <= 100001; ++i ){
    long long num = i*i;
    while(num <= 10000000001L){
      p[c++] = num;
      num*=i;
    }
  }
  ```
  Take care with the repeated numbers that can be formed.

  Then comes the first cool observation.

  The distance of the numbers in the input is less than 10^6, so we can use binary search to find the indices 'from' and 'to' which
  represent the indices of first and last perfect power in the interval, respectively.

  With this information, we proceed to count the number of perfect BST with N elements ('to' - 'from' +1).

  Firstly I think solve this problem using dp, and the following idea arises.

  ```cpp
  F[0] = F[1] = 1;
  F[2] = 2;

  for(int i = 3; i < MAX_ELE; ++i ){
    F[i] = 0;
    for(int j = 0; j < i; ++j)
      F[i] += F[j]*F[i-j-1];
  }
  ```

  Evidently is not fast enough, its complexity is O(N\*N) and it is not feasible in two seconds.

  So I searched in google about the numbers generated by my dp function and i found that these numbers are the catalan numbers[1](http://en.wikipedia.org/wiki/Catalan_number).

  Then I used the 'factorials form' to compute the catalan numbers. Precalculating the factorials and using a bit of modular arithmetic.

  It was a very nice problem, i use dp, binary search, maths ... definitely a good problem.


### Problem source

  [1170 - Counting Perfect BST](http://lightoj.com/volume_showproblem.php?problem=1170)
